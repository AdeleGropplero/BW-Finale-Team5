Index: backend/src/main/java/com/BuildWeek/Team5/Controller/ClienteController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.BuildWeek.Team5.Controller;\r\n\r\nimport com.BuildWeek.Team5.Exception.ClienteNotFound;\r\nimport com.BuildWeek.Team5.Exception.IndirizzoNotFound;\r\nimport com.BuildWeek.Team5.Model.Cliente;\r\nimport com.BuildWeek.Team5.Model.Fattura;\r\nimport com.BuildWeek.Team5.Model.Indirizzo;\r\nimport com.BuildWeek.Team5.Payload.ClienteDTO;\r\nimport com.BuildWeek.Team5.Payload.FatturaDTO;\r\nimport com.BuildWeek.Team5.Payload.IndirizzoDTO;\r\nimport com.BuildWeek.Team5.Repository.ClienteRepository;\r\nimport com.BuildWeek.Team5.Service.ClienteService;\r\nimport com.BuildWeek.Team5.Service.FatturaService;\r\nimport com.BuildWeek.Team5.Service.IndirizzoService;\r\nimport com.cloudinary.Cloudinary;\r\nimport com.cloudinary.utils.ObjectUtils;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.validation.BindingResult;\r\nimport org.springframework.validation.ObjectError;\r\nimport org.springframework.validation.annotation.Validated;\r\nimport org.springframework.web.bind.annotation.*;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.IOException;\r\nimport java.time.LocalDate;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n@RestController\r\n@RequestMapping(\"/cliente\")\r\npublic class ClienteController {\r\n    @Autowired\r\n    ClienteService clienteService;\r\n    @Autowired\r\n    Cloudinary cloudinary;\r\n    @Autowired\r\n    ClienteRepository clienteRepository;\r\n    @Autowired\r\n    FatturaService fatturaService;\r\n\r\n    @Autowired\r\n    IndirizzoService indirizzoService;\r\n\r\n\r\n    //AGGIUNGI un nuovo CLIENTE\r\n    //POSTMAN --> http://localhost:8080/cliente/nuovo\r\n    @PostMapping(\"/nuovo\")\r\n    public ResponseEntity<String> nuovoCliente(@RequestPart(\"dto\") @Validated ArrayList<ClienteDTO> clienteDTOArrayList, BindingResult validation, @RequestPart(\"logoAziendale\") MultipartFile logoAziendale) throws IOException {\r\n        if (validation.hasErrors()) {\r\n            StringBuilder messaggio = new StringBuilder(\"Problemi nella validazione dei dati: \\n\");\r\n\r\n            for (ObjectError error : validation.getAllErrors()) {\r\n                messaggio.append(error.getDefaultMessage()).append(\"\\n\");\r\n            }\r\n            return new ResponseEntity<>(messaggio.toString(), HttpStatus.BAD_REQUEST);\r\n        }\r\n\r\n        try {\r\n            //invio immagine al servizio Cloudinary\r\n            Map mappaUpload = cloudinary.uploader().upload(logoAziendale.getBytes(), ObjectUtils.emptyMap());\r\n            // l'indirizzo dell'immagine\r\n            String urlImage = mappaUpload.get(\"secure_url\").toString();\r\n            // set che setta la nuova immagine\r\n\r\n            //ℹ\uFE0Fℹ\uFE0Fℹ\uFE0F tutti i clienti hanno lo stesso logo\r\n            for (ClienteDTO singoloCliente : clienteDTOArrayList) {\r\n                singoloCliente.setLogoAziendale(urlImage);\r\n            }\r\n\r\n            clienteService.leggiArrayClienti(clienteDTOArrayList);\r\n            return new ResponseEntity<>(\"I clienti sono stati salvati correttamente!\", HttpStatus.CREATED);\r\n        } catch (IOException e) {\r\n            return new ResponseEntity<>(\"Errore!\", HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n    //AGGIUNGI una FATTURA al CLIENTE.\r\n    //POSTMAN --> http://localhost:8080/cliente/addFattura/{clienteID}\r\n    @PatchMapping(\"/addFattura/{clienteID}\")\r\n    public ResponseEntity<String> nuovaFattura(@RequestBody @Validated FatturaDTO fatturaDTO, BindingResult validation, @PathVariable Long clienteID) {\r\n        if (validation.hasErrors()) {\r\n            StringBuilder messaggio = new StringBuilder(\"Problemi nella validazione dei dati: \\n\");\r\n\r\n            for (ObjectError error : validation.getAllErrors()) {\r\n                messaggio.append(error.getDefaultMessage()).append(\"\\n\");\r\n            }\r\n            return new ResponseEntity<>(messaggio.toString(), HttpStatus.BAD_REQUEST);\r\n        }\r\n\r\n        try {\r\n            Cliente cliente = clienteRepository.findById(clienteID).orElseThrow(() -> new ClienteNotFound(\"Cliente non trovato!\"));\r\n            Fattura fattura = fatturaService.fromFatturaDTOtoFattura(fatturaDTO);\r\n            long idFattura = fatturaService.salvaFattura(fattura);\r\n            cliente.getFatture().add(fattura);\r\n            clienteService.salvaCliente(cliente);\r\n            return new ResponseEntity<>(\"La fattura con ID \" + idFattura + \" è stata aggiunta con successo!\", HttpStatus.CREATED);\r\n        } catch (ClienteNotFound e) {\r\n            return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n    //AGGIUNGI un INDIRIZZO al CLIENTE.\r\n    //POSTMAN --> http://localhost:8080/cliente/addIndirizzo/{clienteID}\r\n    @PatchMapping(\"/addIndirizzo/{clienteID}\")\r\n    public ResponseEntity<String> addIndirizzoAlCliente(@RequestBody @Validated IndirizzoDTO indirizzoDTO, BindingResult validation, @PathVariable Long clienteID) {\r\n        if (validation.hasErrors()) {\r\n            StringBuilder messaggio = new StringBuilder(\"Problemi nella validazione dei dati: \\n\");\r\n\r\n            for (ObjectError error : validation.getAllErrors()) {\r\n                messaggio.append(error.getDefaultMessage()).append(\"\\n\");\r\n            }\r\n            return new ResponseEntity<>(messaggio.toString(), HttpStatus.BAD_REQUEST);\r\n        }\r\n\r\n        try {\r\n            String indirizzoAggiunto = indirizzoService.addIndirizzo(clienteID, indirizzoDTO);\r\n            return new ResponseEntity<>(indirizzoAggiunto, HttpStatus.CREATED);\r\n        } catch (ClienteNotFound e) {\r\n            return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n\r\n    //post Indirizzo. (questo endpoint ci serviva in fase iniziale ma dubito che lo useremo più, dopo l'aggiunta della patch)\r\n    @PostMapping(\"/indirizzo\")\r\n    public ResponseEntity<String> inserisciIndirizzo(@Validated @RequestBody IndirizzoDTO indirizzoDTO, BindingResult validation) {\r\n        if (validation.hasErrors()) {\r\n            StringBuilder messaggio = new StringBuilder(\"Problemi nella validazione dei dati: \\n\");\r\n\r\n            for (ObjectError error : validation.getAllErrors()) {\r\n                messaggio.append(error.getDefaultMessage()).append(\"\\n\");\r\n            }\r\n            return new ResponseEntity<>(messaggio.toString(), HttpStatus.BAD_REQUEST);\r\n        }\r\n\r\n        try {\r\n            String indirizzo = indirizzoService.insertIndirizzo(indirizzoDTO);\r\n\r\n            return new ResponseEntity<>(\"Indirizzo inserito: \" + indirizzo, HttpStatus.CREATED);\r\n        } catch (IndirizzoNotFound e) {\r\n            return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n    //post Indirizzi. (questo endpoint ci serviva in fase iniziale ma dubito che lo useremo più, dopo l'aggiunta della patch)\r\n    @PostMapping(\"/batchIndirizzi\")\r\n    public ResponseEntity<String> inserisciIndirizzi(@Validated @RequestBody List<IndirizzoDTO> listaDto, BindingResult validation) {\r\n        if (validation.hasErrors()) {\r\n            StringBuilder messaggio = new StringBuilder(\"Problemi nella validazione dei dati: \\n\");\r\n\r\n            for (ObjectError error : validation.getAllErrors()) {\r\n                messaggio.append(error.getDefaultMessage()).append(\"\\n\");\r\n            }\r\n            return new ResponseEntity<>(messaggio.toString(), HttpStatus.BAD_REQUEST);\r\n        }\r\n        try {\r\n            String indirizziInseriti = indirizzoService.insertIndirizzi(listaDto);\r\n            return new ResponseEntity<>(indirizziInseriti, HttpStatus.CREATED);\r\n        } catch (IndirizzoNotFound e) {\r\n            return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n    //Ordinamento liste clienti --------------------------------------------------\r\n\r\n    @GetMapping(\"/clientiAZ\")\r\n    public ResponseEntity<String> getClientiAZ() {\r\n        try {\r\n            String clientiAZ = clienteService.clientiAZ();\r\n            return new ResponseEntity<>(clientiAZ, HttpStatus.OK);\r\n        } catch (ClienteNotFound e) {\r\n            return new ResponseEntity<>(\"Non è stato trovato nessun cliente\", HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n    @GetMapping(\"/clientiPerFatturato\")\r\n    public ResponseEntity<String> clientiPerFatturato() {\r\n        try {\r\n            String clientiPerFatturato = clienteService.clientiPerFatturato();\r\n            return new ResponseEntity<>(clientiPerFatturato, HttpStatus.OK);\r\n        } catch (ClienteNotFound e) {\r\n            return new ResponseEntity<>(\"Non è stato trovato nessun cliente\", HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n    @GetMapping(\"/clientiPerDataInserimento\")\r\n    public ResponseEntity<String> clientiPerDataInserimento() {\r\n        try {\r\n            String clientiPerDataInserimento = clienteService.clientiPerDataInserimento();\r\n            return new ResponseEntity<>(clientiPerDataInserimento, HttpStatus.OK);\r\n        } catch (ClienteNotFound e) {\r\n            return new ResponseEntity<>(\"Non è stato trovato nessun cliente\", HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n    @GetMapping(\"/clientiPerDataUltimoContatto\")\r\n    public ResponseEntity<String> clientiPerDataUltimoContatto() {\r\n        try {\r\n            String clientiPerDataUltimoContatto = clienteService.clientiPerDataUltimoContatto();\r\n            return new ResponseEntity<>(clientiPerDataUltimoContatto, HttpStatus.OK);\r\n        } catch (ClienteNotFound e) {\r\n            return new ResponseEntity<>(\"Non è stato trovato nessun cliente\", HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n    @GetMapping(\"/clientiPerProvinciaSedeLegale\")\r\n    public ResponseEntity<String> clientiPerProvinciaSedeLegale() {\r\n        try {\r\n            String clientiPerProvinciaSedeLegale = clienteService.clientiPerProvinciaSedeLegale();\r\n            return new ResponseEntity<>(clientiPerProvinciaSedeLegale, HttpStatus.OK);\r\n        } catch (ClienteNotFound e) {\r\n            return new ResponseEntity<>(\"Non è stato trovato nessun cliente\", HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n    //----------------------------------------------------------------------------------------------------\r\n    //Filtra liste clienti --------------------------------------------------\r\n    @GetMapping(\"/fatturatoAnnuale\")\r\n    public ResponseEntity<?> getClientiByFatturatoAnnuale(@RequestParam double fatturatoAnnuale) {\r\n        try {\r\n            List<Cliente> listaClienti = clienteService.getByFatturatoAnnuale(fatturatoAnnuale);\r\n            return new ResponseEntity<>(listaClienti, HttpStatus.OK);\r\n        } catch (ClienteNotFound e) {\r\n            return new ResponseEntity<>(\"Non è stato trovato nessun cliente\", HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n    @GetMapping(\"/dataInserimento\")\r\n    public ResponseEntity<?> getClienteByDataInserimento(@RequestParam LocalDate dataInserimento) {\r\n        try {\r\n            List<Cliente> listaClienti = clienteService.getByDataInserimento(dataInserimento);\r\n            return new ResponseEntity<>(listaClienti, HttpStatus.OK);\r\n        } catch (ClienteNotFound e) {\r\n            return new ResponseEntity<>(\"Nessun cliente trovato!\", HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n    @GetMapping(\"/dataUltimoContatto\")\r\n    public ResponseEntity<?> getClientiByUltimoContatto(@RequestParam LocalDate dataUltimoContatto) {\r\n        try {\r\n            List<Cliente> listaClienti = clienteService.getByDataUltimoContatto(dataUltimoContatto);\r\n            return new ResponseEntity<>(listaClienti, HttpStatus.OK);\r\n        } catch (ClienteNotFound e) {\r\n            return new ResponseEntity<>(\"Nessun cliente trovato!\", HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n\r\n    @GetMapping(\"/nomeContatto\")\r\n    public ResponseEntity<?> getClientiByNomeContatto(@RequestParam String nomeContatto) {\r\n        try {\r\n            List<Cliente> listaClienti = clienteService.getByNomeContatto(nomeContatto);\r\n            return new ResponseEntity<>(listaClienti, HttpStatus.OK);\r\n        } catch (ClienteNotFound e) {\r\n            return new ResponseEntity<>(\"Nessun cliente trovato!\", HttpStatus.BAD_REQUEST);\r\n        }\r\n    }\r\n    //----------------------------------------------------------------------------------------------------\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/backend/src/main/java/com/BuildWeek/Team5/Controller/ClienteController.java b/backend/src/main/java/com/BuildWeek/Team5/Controller/ClienteController.java
--- a/backend/src/main/java/com/BuildWeek/Team5/Controller/ClienteController.java	(revision ca7a294073d795946f02ba49d1a9ceb67b6c0102)
+++ b/backend/src/main/java/com/BuildWeek/Team5/Controller/ClienteController.java	(date 1740664968883)
@@ -257,5 +257,10 @@
             return new ResponseEntity<>("Nessun cliente trovato!", HttpStatus.BAD_REQUEST);
         }
     }
+
+    @GetMapping("/allClients")
+    public List<Cliente> getAllClients(){
+        return clienteRepository.findAll();
+    }
     //----------------------------------------------------------------------------------------------------
 }
Index: backend/src/main/java/com/BuildWeek/Team5/Security/WebSecurityConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.BuildWeek.Team5.Security;\r\n\r\nimport com.BuildWeek.Team5.Security.JWT.AuthEntryPoint;\r\nimport com.BuildWeek.Team5.Security.JWT.JwtAuthTokenFilter;\r\nimport com.BuildWeek.Team5.Security.Services.UtenteDetailsServiceImpl;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.security.authentication.AuthenticationManager;\r\nimport org.springframework.security.authentication.dao.DaoAuthenticationProvider;\r\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\r\nimport org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;\r\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\r\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\r\nimport org.springframework.security.config.http.SessionCreationPolicy;\r\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.security.web.SecurityFilterChain;\r\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\r\nimport org.springframework.web.servlet.config.annotation.CorsRegistry;\r\n\r\n@Configuration\r\n@EnableMethodSecurity\r\n@EnableWebSecurity(debug = true)\r\n\r\npublic class WebSecurityConfig {\r\n\r\n    @Autowired\r\n    UtenteDetailsServiceImpl utenteDetailsService;\r\n\r\n    @Autowired\r\n    AuthEntryPoint authEntryPoint;\r\n\r\n    // metodo che genera un oggetto per criptare la password\r\n    @Bean\r\n    public PasswordEncoder passwordEncoder(){\r\n        return new BCryptPasswordEncoder();\r\n    }\r\n\r\n    // metodo che fornisce l'autenticazione attraverso i dettagli dell'utente\r\n    @Bean\r\n    public DaoAuthenticationProvider authenticationProvider(){\r\n\r\n        DaoAuthenticationProvider auth = new DaoAuthenticationProvider();\r\n\r\n        auth.setUserDetailsService(utenteDetailsService);\r\n\r\n        // DaoAuthenticationProvider fornisce un metodo per accettare la password criptata\r\n\r\n        auth.setPasswordEncoder(passwordEncoder());\r\n\r\n        return auth;\r\n    }\r\n\r\n    @Bean\r\n    public JwtAuthTokenFilter authTokenFilter(){\r\n        return new JwtAuthTokenFilter();\r\n    }\r\n\r\n    // Espone il bean AuthenticationManager\r\n    @Bean\r\n    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {\r\n        return authenticationConfiguration.getAuthenticationManager();\r\n    }\r\n\r\n    // creazione di un bean dedicato ai filtri\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http.csrf(csrf -> csrf.disable())\r\n                .exceptionHandling(exception -> exception.authenticationEntryPoint(authEntryPoint))\r\n                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\r\n                .authorizeHttpRequests(auth ->\r\n                        auth.requestMatchers(\"/utente/**\").permitAll()\r\n                                .requestMatchers(\"/cliente/**\").permitAll()\r\n                                .requestMatchers(\"/fattura/**\").permitAll()\r\n                                .requestMatchers(\"/admin/**\").hasAuthority(\"ADMIN\")\r\n                                .anyRequest().authenticated());\r\n\r\n\r\n        http.addFilterBefore(authTokenFilter(), UsernamePasswordAuthenticationFilter.class);\r\n        http.authenticationProvider(authenticationProvider());\r\n\r\n        return http.build();\r\n    }\r\n\r\n    public void addCorsMappings(CorsRegistry registry) {\r\n        registry.addMapping(\"/**\")\r\n                .allowedOrigins(\"http://localhost:5173\") // React/Vite dev server\r\n                .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\r\n                .allowedHeaders(\"*\")\r\n                .allowCredentials(true);\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/backend/src/main/java/com/BuildWeek/Team5/Security/WebSecurityConfig.java b/backend/src/main/java/com/BuildWeek/Team5/Security/WebSecurityConfig.java
--- a/backend/src/main/java/com/BuildWeek/Team5/Security/WebSecurityConfig.java	(revision ca7a294073d795946f02ba49d1a9ceb67b6c0102)
+++ b/backend/src/main/java/com/BuildWeek/Team5/Security/WebSecurityConfig.java	(date 1740663611494)
@@ -66,7 +66,8 @@
     // creazione di un bean dedicato ai filtri
     @Bean
     public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
-        http.csrf(csrf -> csrf.disable())
+        http.cors(cors -> cors.configure(http))
+        .csrf(csrf -> csrf.disable())
                 .exceptionHandling(exception -> exception.authenticationEntryPoint(authEntryPoint))
                 .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                 .authorizeHttpRequests(auth ->
@@ -83,13 +84,4 @@
         return http.build();
     }
 
-    public void addCorsMappings(CorsRegistry registry) {
-        registry.addMapping("/**")
-                .allowedOrigins("http://localhost:5173") // React/Vite dev server
-                .allowedMethods("GET", "POST", "PUT", "DELETE")
-                .allowedHeaders("*")
-                .allowCredentials(true);
-    }
-
-
 }
Index: backend/src/main/java/com/BuildWeek/Team5/Configurguration/CorsConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/backend/src/main/java/com/BuildWeek/Team5/Configurguration/CorsConfig.java b/backend/src/main/java/com/BuildWeek/Team5/Configurguration/CorsConfig.java
new file mode 100644
--- /dev/null	(date 1740663792171)
+++ b/backend/src/main/java/com/BuildWeek/Team5/Configurguration/CorsConfig.java	(date 1740663792171)
@@ -0,0 +1,19 @@
+package com.BuildWeek.Team5.Configurguration;
+
+import org.springframework.context.annotation.Configuration;
+import org.springframework.web.servlet.config.annotation.CorsRegistry;
+import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
+
+@Configuration
+
+public class CorsConfig implements WebMvcConfigurer {
+
+    @Override
+    public void addCorsMappings(CorsRegistry registry) {
+        registry.addMapping("/**")
+                .allowedOrigins("http://localhost:5173") // React/Vite dev server
+                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
+                .allowedHeaders("*")
+                .allowCredentials(true);
+    }
+}
